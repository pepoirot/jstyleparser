/* Generated By:JJTree&JavaCC: Do not edit this line. CSSParser.java */
package cz.vutbr.web.csskit.javacc;

import java.io.Reader;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.HashSet;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import cz.vutbr.web.css.CSSFactory;
import cz.vutbr.web.css.CombinedSelector;
import cz.vutbr.web.css.Declaration;
import cz.vutbr.web.css.RuleImport;
import cz.vutbr.web.css.Rule;
import cz.vutbr.web.css.RuleBlock;
import cz.vutbr.web.css.RuleBlock.Priority;
import cz.vutbr.web.css.RuleFactory;
import cz.vutbr.web.css.RuleMedia;
import cz.vutbr.web.css.RulePage;
import cz.vutbr.web.css.RuleSet;
import cz.vutbr.web.css.Selector;
import cz.vutbr.web.css.StyleSheet;
import cz.vutbr.web.css.CSSException;
import cz.vutbr.web.css.Term;
import cz.vutbr.web.css.TermFactory;
import cz.vutbr.web.css.TermFunction;
import cz.vutbr.web.css.TermIdent;
import cz.vutbr.web.css.TermNumeric;

import cz.vutbr.web.csskit.PriorityStrategy;

/**
 * Parser of CSS passed as InputStream, Reader or directly as String.
 * Successful parsing creates StyleSheet  	
 */
@SuppressWarnings({"unused","unchecked","deprecation"})
public class CSSParser/*@bgen(jjtree)*/implements CSSParserTreeConstants, CSSParserConstants {/*@bgen(jjtree)*/
  protected JJTCSSParserState jjtree = new JJTCSSParserState();
        private static Logger log = LoggerFactory.getLogger(CSSParser.class);

        private static final TermFactory tf = CSSFactory.getTermFactory();
        private static final RuleFactory rf = CSSFactory.getRuleFactory();

         /**
      * This flag causes skipping of token with checking for 
      * type of next token. Use it with errorRecover function
      * Note:
      * This negative value should be never identification of token
      */
    private static final int FAST_SKIP = -10;


    // priority using integer value
        private static final class PriorityImpl implements Priority {
                final int priority;
                public PriorityImpl(int priority) { this.priority = priority; }

                public int compareTo(Priority o) {
                        if(!(o instanceof PriorityImpl))
                                throw new ClassCastException("Unable to compare with different instance of priority: " + o.getClass());
                        PriorityImpl other = (PriorityImpl) o;
                        return this.priority - other.priority;
                }

                @Override
                public String toString() {
                        return String.valueOf(priority);
                }
        }

        private PriorityStrategy ps = new PriorityStrategy() {
                int counter = 0;
            public Priority getAndIncrement() {
                return new PriorityImpl(counter++);
            }
            public Priority markAndIncrement() {
                return new PriorityImpl(counter++);
            }
   };

        /** Character set of given css */
        private String charset;

        /** Rules gathered from input */
        private List<RuleBlock<?>> rules = new ArrayList<RuleBlock<?>>();

        /**
	 * Error recovery.
	 * Skip to given token in case of error.
	 * End of File (EOF) token is added automatically.
	 * @param e Exception to be logged  
	 * @param message message to be logged
	 * @param kinds Type(s) of token where to continue, if <code>null</code> do not skip anything  
	 */
        private void errorRecover(final ParseException exception, final String message, final int...kinds) {

                if(log.isInfoEnabled()) {
                        if(log.isDebugEnabled()) {
                                log.debug(message, exception);
                        }
                        else {
                                log.info(message);
                        }
                }

                // don't do skipping
                if(kinds.length==0) return;


            // use auto boxing and unboxing, not very pretty 
                // construct stop tokens
                // array list should be faster for this situation
                Set<Integer>  stopTokens = new HashSet<Integer>(kinds.length + 1);
                for(int i = 0; i < kinds.length; i++)
                        stopTokens.add(new Integer(kinds[i]));

                stopTokens.add(EOF);

                // TODO: is this appropriate behavior?
                boolean first = true;
                Token t;
                do {
                        t = getNextToken();
                        if(first) {
                                if(log.isTraceEnabled()) {
                                        log.trace("Failed on token: " +
                                        CSSParserConstants.tokenImage[t.kind] +
                                        " = " + t.image);
                                        first = false;
                                }
                        }
                }while(!(stopTokens.contains(t.kind) || stopTokens.contains(FAST_SKIP)));

                if(log.isTraceEnabled()) {
                        log.trace("Recovered on token: " + CSSParserConstants.tokenImage[t.kind] + " = " + t.image );
                }

        }

/**
 * Parses input and returns gathered information as StyleSheet.
 * @return StyleSheet which contains rules gathered.
 * @see StyleSheet
 */
  final public StyleSheet stylesheet() throws ParseException {
 /*@bgen(jjtree) stylesheet */
  SimpleNode jjtn000 = new SimpleNode(JJTSTYLESHEET);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CHARSET_SYM:
          charset();
          break;
        default:
          jj_la1[0] = jj_gen;
          ;
        }
        label_1:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case BLANK:
          case CDO:
          case CDC:
            ;
            break;
          default:
            jj_la1[1] = jj_gen;
            break label_1;
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case BLANK:
            jj_consume_token(BLANK);
            break;
          case CDO:
            jj_consume_token(CDO);
            break;
          case CDC:
            jj_consume_token(CDC);
            break;
          default:
            jj_la1[2] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        label_2:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IMPORT_SYM:
            ;
            break;
          default:
            jj_la1[3] = jj_gen;
            break label_2;
          }
          import_a();
          label_3:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case BLANK:
            case CDO:
            case CDC:
              ;
              break;
            default:
              jj_la1[4] = jj_gen;
              break label_3;
            }
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case BLANK:
              jj_consume_token(BLANK);
              break;
            case CDO:
              jj_consume_token(CDO);
              break;
            case CDC:
              jj_consume_token(CDC);
              break;
            default:
              jj_la1[5] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
        label_4:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LBRACE:
          case IDENT:
          case HASH:
          case PAGE_SYM:
          case MEDIA_SYM:
          case 66:
          case 67:
          case 68:
            ;
            break;
          default:
            jj_la1[6] = jj_gen;
            break label_4;
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LBRACE:
          case IDENT:
          case HASH:
          case 66:
          case 67:
          case 68:
            ruleset(rules);
            break;
          case MEDIA_SYM:
            media();
            break;
          case PAGE_SYM:
            page();
            break;
          default:
            jj_la1[7] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          label_5:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case BLANK:
            case CDO:
            case CDC:
              ;
              break;
            default:
              jj_la1[8] = jj_gen;
              break label_5;
            }
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case BLANK:
              jj_consume_token(BLANK);
              break;
            case CDO:
              jj_consume_token(CDO);
              break;
            case CDC:
              jj_consume_token(CDC);
              break;
            default:
              jj_la1[9] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
      } catch (ParseException e) {
                errorRecover(e, "f: stylesheet()");
      } finally {
                StyleSheet stylesheet = rf.createStyleSheet();
                stylesheet.replaceAll(rules);

                {if (true) return stylesheet;}
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Internally sets charset of document. 
 */
  final public void charset() throws ParseException {
 /*@bgen(jjtree) charset */
 SimpleNode jjtn000 = new SimpleNode(JJTCHARSET);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);String currentCharset = null;
    try {
      try {
        jj_consume_token(CHARSET_SYM);
        currentCharset = string();
        jj_consume_token(SEMICOLON);
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                        charset = currentCharset;
      } catch (ParseException e) {
                // according to CSS UA
                // ignore until next block is found
                errorRecover(e, "f: charset(), failed to retrieve", RCURLY);
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

/**
 * Creates and add new import rule to stylesheet 
 */
  final public void import_a() throws ParseException {
 /*@bgen(jjtree) import_a */
        SimpleNode jjtn000 = new SimpleNode(JJTIMPORT_A);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);String currentUri = null;
        List<String> medias = new ArrayList<String>();
    try {
      try {
        jj_consume_token(IMPORT_SYM);
        label_6:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case BLANK:
            ;
            break;
          default:
            jj_la1[10] = jj_gen;
            break label_6;
          }
          jj_consume_token(BLANK);
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STRING:
        case URI:
          currentUri = string_or_uri();
          label_7:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case BLANK:
              ;
              break;
            default:
              jj_la1[11] = jj_gen;
              break label_7;
            }
            jj_consume_token(BLANK);
          }
          break;
        default:
          jj_la1[12] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENT:
          medium(medias);
          label_8:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case COMMA:
              ;
              break;
            default:
              jj_la1[13] = jj_gen;
              break label_8;
            }
            jj_consume_token(COMMA);
            label_9:
            while (true) {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case BLANK:
                ;
                break;
              default:
                jj_la1[14] = jj_gen;
                break label_9;
              }
              jj_consume_token(BLANK);
            }
            medium(medias);
          }
          break;
        default:
          jj_la1[15] = jj_gen;
          ;
        }
        jj_consume_token(SEMICOLON);
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                        if(currentUri!=null || !"".equals(currentUri)) {
                                RuleImport uri = rf.createImport(ps.getAndIncrement());
                                uri.setURI(currentUri);
                                uri.replaceAll(medias);
                                this.rules.add(uri);
                        }
      } catch (ParseException e) {
                errorRecover(e, "f: import_a()", BLANK);
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

/**
 * Creates and sets new media rule to stylesheet
 */
  final public void media() throws ParseException {
 /*@bgen(jjtree) media */
        SimpleNode jjtn000 = new SimpleNode(JJTMEDIA);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);List<String> medias = new ArrayList<String>();
        List<? extends RuleBlock<?>> mediarules = new ArrayList<RuleSet>();
    try {
      try {
        jj_consume_token(MEDIA_SYM);
        label_10:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case BLANK:
            ;
            break;
          default:
            jj_la1[16] = jj_gen;
            break label_10;
          }
          jj_consume_token(BLANK);
        }
        medium(medias);
        label_11:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[17] = jj_gen;
            break label_11;
          }
          jj_consume_token(COMMA);
          label_12:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case BLANK:
              ;
              break;
            default:
              jj_la1[18] = jj_gen;
              break label_12;
            }
            jj_consume_token(BLANK);
          }
          medium(medias);
        }
        jj_consume_token(LCURLY);
        label_13:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case BLANK:
            ;
            break;
          default:
            jj_la1[19] = jj_gen;
            break label_13;
          }
          jj_consume_token(BLANK);
        }
        label_14:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LBRACE:
          case IDENT:
          case HASH:
          case 66:
          case 67:
          case 68:
            ;
            break;
          default:
            jj_la1[20] = jj_gen;
            break label_14;
          }
          ruleset((List<RuleBlock<?>>) mediarules);
        }
        jj_consume_token(RCURLY);
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                        RuleMedia media = rf.createMedia(ps.getAndIncrement());
                        media.setMedia(medias);
                        media.replaceAll( (List<RuleSet>) mediarules);
                        rules.add(media);
      } catch (ParseException e) {
                errorRecover(e, "f: media()", RCURLY);
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

/**
 * Adds media to list.
 * @param medias Current list of associated medias
 */
  final public void medium(List<String> medias) throws ParseException {
 /*@bgen(jjtree) medium */
        SimpleNode jjtn000 = new SimpleNode(JJTMEDIUM);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);String currentMedia = null;
    try {
      try {
        currentMedia = ident();
        label_15:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case BLANK:
            ;
            break;
          default:
            jj_la1[21] = jj_gen;
            break label_15;
          }
          jj_consume_token(BLANK);
        }
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                        medias.add(currentMedia);
      } catch (ParseException e) {
                errorRecover(e, "f: medium()", BLANK);
      } catch (IllegalArgumentException e) {
                log.warn("Multiple definition of media :" + currentMedia);
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

/**
 * Inserts ruleset's rule into rule set
 * @param rules List of rules where new ruleset will be added
 */
  final public void ruleset(List<RuleBlock<?>> rules) throws ParseException {
 /*@bgen(jjtree) ruleset */
        SimpleNode jjtn000 = new SimpleNode(JJTRULESET);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);List<CombinedSelector> cslist = new ArrayList<CombinedSelector>();
        List<Declaration> declarations = new ArrayList<Declaration>();

        CombinedSelector cs = null;
        Declaration dec = null;
    try {
      try {
        cs = combined_selector();
                        if(cs!=null) cslist.add(cs);
        label_16:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[22] = jj_gen;
            break label_16;
          }
          jj_consume_token(COMMA);
          label_17:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case BLANK:
              ;
              break;
            default:
              jj_la1[23] = jj_gen;
              break label_17;
            }
            jj_consume_token(BLANK);
          }
          cs = combined_selector();
                                if(cs!=null) cslist.add(cs);
        }
        jj_consume_token(LCURLY);
        label_18:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case BLANK:
            ;
            break;
          default:
            jj_la1[24] = jj_gen;
            break label_18;
          }
          jj_consume_token(BLANK);
        }
        dec = declaration();
                                // store declaration
                                if(dec != null) declarations.add(dec);
        label_19:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SEMICOLON:
            ;
            break;
          default:
            jj_la1[25] = jj_gen;
            break label_19;
          }
          jj_consume_token(SEMICOLON);
          label_20:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case BLANK:
              ;
              break;
            default:
              jj_la1[26] = jj_gen;
              break label_20;
            }
            jj_consume_token(BLANK);
          }
          dec = declaration();
                                        // store another declaration
                                        if(dec != null) declarations.add(dec);
        }
        jj_consume_token(RCURLY);
      } catch (ParseException e) {
                errorRecover(e, "f: ruleset()", RCURLY);
      } finally {
                if(cslist.size() > 0 && declarations.size() > 0) {
                        RuleSet rule = rf.createSet(ps.getAndIncrement());
                        rule.setSelectors(cslist);
                        rule.replaceAll(declarations);
                        rules.add(rule);
                }
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

/**
 * Inserts page rule as stylesheet rule 
 */
  final public void page() throws ParseException {
 /*@bgen(jjtree) page */
        SimpleNode jjtn000 = new SimpleNode(JJTPAGE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);List<Declaration> declarations = new ArrayList<Declaration>();
        Declaration dec = null;
        String pseudo = null;
    try {
      try {
        jj_consume_token(PAGE_SYM);
        label_21:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case BLANK:
            ;
            break;
          default:
            jj_la1[27] = jj_gen;
            break label_21;
          }
          jj_consume_token(BLANK);
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 66:
          pseudo = pseudo_page();
          label_22:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case BLANK:
              ;
              break;
            default:
              jj_la1[28] = jj_gen;
              break label_22;
            }
            jj_consume_token(BLANK);
          }
          break;
        default:
          jj_la1[29] = jj_gen;
          ;
        }
        jj_consume_token(LCURLY);
        label_23:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case BLANK:
            ;
            break;
          default:
            jj_la1[30] = jj_gen;
            break label_23;
          }
          jj_consume_token(BLANK);
        }
        dec = declaration();
                        // add declaration
                        if(dec != null) declarations.add(dec);
        label_24:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SEMICOLON:
            ;
            break;
          default:
            jj_la1[31] = jj_gen;
            break label_24;
          }
          jj_consume_token(SEMICOLON);
          label_25:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case BLANK:
              ;
              break;
            default:
              jj_la1[32] = jj_gen;
              break label_25;
            }
            jj_consume_token(BLANK);
          }
          dec = declaration();
                                // add declaration
                                if(dec != null) declarations.add(dec);
        }
        jj_consume_token(RCURLY);
      } catch (ParseException e) {
                errorRecover(e, "f: page()", RCURLY);
      } finally {
                if(declarations.size() > 0) {
                        RulePage page = rf.createPage(ps.getAndIncrement());
                        page.setPseudo(pseudo);
                        page.replaceAll(declarations);
                this.rules.add(page);
                }
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

/**
 * Retrieve pseudo for page
 * @return Pseudo of current page
 */
  final public String pseudo_page() throws ParseException {
 /*@bgen(jjtree) pseudo_page */
        SimpleNode jjtn000 = new SimpleNode(JJTPSEUDO_PAGE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);String pseudo = null;
    try {
      jj_consume_token(66);
      pseudo = ident();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
        {if (true) return pseudo;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Returns new declaration
 * @return declaration
 */
  final public Declaration declaration() throws ParseException {
 /*@bgen(jjtree) declaration */
        SimpleNode jjtn000 = new SimpleNode(JJTDECLARATION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Declaration declaration = rf.createDeclaration();
        List<Term<?>> terms = null;
        String property = null;
        boolean important = false;
    try {
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENT:
          property = property();
          jj_consume_token(66);
          label_26:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case BLANK:
              ;
              break;
            default:
              jj_la1[33] = jj_gen;
              break label_26;
            }
            jj_consume_token(BLANK);
          }
          terms = expr();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IMPORTANT_SYM:
            important = prio();
            break;
          default:
            jj_la1[34] = jj_gen;
            ;
          }
          break;
        default:
          jj_la1[35] = jj_gen;
          ;
        }
      } catch (ParseException e) {
                errorRecover(e, "f: declaration()", BLANK, NL, SEMICOLON, RCURLY);
      } finally {
                // do not allow improperly filled declaration
                if(terms==null || property==null)
                        {if (true) return null;}

                declaration.setImportant(important);
                declaration.setProperty(property);
                declaration.replaceAll(terms);

                if(log.isDebugEnabled()) {
                        log.debug("Having declaration of property: " + property +
                                ", and " + declaration.size() + " terms " + terms);
                }
                {if (true) return declaration;}
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Returns name of property
 * @return Name of property
 */
  final public String property() throws ParseException {
 /*@bgen(jjtree) property */
        SimpleNode jjtn000 = new SimpleNode(JJTPROPERTY);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);String currentProperty = null;
    try {
      currentProperty = ident();
      label_27:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BLANK:
          ;
          break;
        default:
          jj_la1[36] = jj_gen;
          break label_27;
        }
        jj_consume_token(BLANK);
      }
                                               jjtree.closeNodeScope(jjtn000, true);
                                               jjtc000 = false;
                                               {if (true) return currentProperty;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Returns selector for given rules
 * @return CombinedSelector  
 */
  final public CombinedSelector combined_selector() throws ParseException {
 /*@bgen(jjtree) combined_selector */
        SimpleNode jjtn000 = new SimpleNode(JJTCOMBINED_SELECTOR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);CombinedSelector cs = rf.createCombinedSelector();
        List<Selector> list = new ArrayList<Selector>();
        Selector selector = null;
        Selector.Combinator c = null;
    try {
      try {
        selector = selector();
                                if(selector!=null) list.add(selector);
        label_28:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case BLANK:
          case PLUS:
          case GREATER:
            ;
            break;
          default:
            jj_la1[37] = jj_gen;
            break label_28;
          }
          c = combinator();
                                if(log.isTraceEnabled()) {
                                        log.trace("Combinator: " + c);
                                }
          selector = selector();
                                        if(selector!=null) {
                                                selector.setCombinator(c);
                                                list.add(selector);
                                        }
        }
      } catch (ParseException e) {
                errorRecover(e, "f: combined_selector()", BLANK, LCURLY);
      } finally {
                if(log.isDebugEnabled()) {
                        log.debug("Having selectors(" + list.size() + "): " + list);
                }
                cs.replaceAll(list);
                {if (true) return cs;}
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Returns selector
 * @return Selector as a part of CombinedSelector
 */
  final public Selector selector() throws ParseException {
 /*@bgen(jjtree) selector */
        SimpleNode jjtn000 = new SimpleNode(JJTSELECTOR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Selector selector = (Selector) rf.createSelector().unlock();
        String value = null;
        Selector.SelectorPart item = null;
    try {
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENT:
        case 68:
          value = element_name();
                                selector.add(rf.createElement(value));
          label_29:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case LBRACE:
            case HASH:
            case 66:
            case 67:
              ;
              break;
            default:
              jj_la1[38] = jj_gen;
              break label_29;
            }
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case HASH:
              value = hash();
                                        item = rf.createID(value);
                                        if(item != null) selector.add(item);
              break;
            case 67:
              item = class_a();
                                        if(item!=null) selector.add(item);
              break;
            case LBRACE:
              item = attrib();
                                        if(item!=null) selector.add(item);
              break;
            case 66:
              item = pseudo();
                                        if(item!=null) selector.add(item);
              break;
            default:
              jj_la1[39] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
          break;
        case LBRACE:
        case HASH:
        case 66:
        case 67:
          label_30:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case HASH:
              value = hash();
                                        item = rf.createID(value);
                                        if(item != null) selector.add(item);
              break;
            case 67:
              item = class_a();
                                        if(item!=null) selector.add(item);
              break;
            case LBRACE:
              item = attrib();
                                        if(item!=null) selector.add(item);
              break;
            case 66:
              item = pseudo();
                                        if(item!=null) selector.add(item);
              break;
            default:
              jj_la1[40] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case LBRACE:
            case HASH:
            case 66:
            case 67:
              ;
              break;
            default:
              jj_la1[41] = jj_gen;
              break label_30;
            }
          }
          break;
        default:
          jj_la1[42] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (ParseException e) {
                errorRecover(e, "f: selector()", BLANK, LCURLY);
      } catch (Exception e) {
                log.warn("f: selector(): ", e);
      } finally {
                if(log.isTraceEnabled()) {
                        log.trace("Returning selector: " + selector);
                }

                {if (true) return selector;}
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Returns .class simple selector
 */
  final public Selector.ElementClass class_a() throws ParseException {
 /*@bgen(jjtree) class_a */
        SimpleNode jjtn000 = new SimpleNode(JJTCLASS_A);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);String value = null;
    try {
      jj_consume_token(67);
      value = ident();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                {if (true) return rf.createClass(value);}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Returns name of element for selector.
 * @return Name of element or asterisk
 */
  final public String element_name() throws ParseException {
 /*@bgen(jjtree) element_name */
        SimpleNode jjtn000 = new SimpleNode(JJTELEMENT_NAME);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);String element = null;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENT:
        element = ident();
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                          {if (true) return element;}
        break;
      case 68:
        jj_consume_token(68);
                                                   jjtree.closeNodeScope(jjtn000, true);
                                                   jjtc000 = false;
                                                  {if (true) return "*";}
        break;
      default:
        jj_la1[43] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Returns [attribute] 
 */
  final public Selector.ElementAttribute attrib() throws ParseException {
 /*@bgen(jjtree) attrib */
        SimpleNode jjtn000 = new SimpleNode(JJTATTRIB);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);String attribute = null;
        String value = null;
        boolean isStringValue = false;  // default value is identificator, so false
        Selector.Operator op = Selector.Operator.NO_OPERATOR;
    try {
      try {
        jj_consume_token(LBRACE);
        label_31:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case BLANK:
            ;
            break;
          default:
            jj_la1[44] = jj_gen;
            break label_31;
          }
          jj_consume_token(BLANK);
        }
        attribute = ident();
        label_32:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case BLANK:
            ;
            break;
          default:
            jj_la1[45] = jj_gen;
            break label_32;
          }
          jj_consume_token(BLANK);
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EQUAL:
        case INCLUDES:
        case DASHMATCH:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case EQUAL:
            op = equal();
            break;
          case INCLUDES:
            op = includes();
            break;
          case DASHMATCH:
            op = dashmatch();
            break;
          default:
            jj_la1[46] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          label_33:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case BLANK:
              ;
              break;
            default:
              jj_la1[47] = jj_gen;
              break label_33;
            }
            jj_consume_token(BLANK);
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IDENT:
            value = ident();
                                          isStringValue = false;
            break;
          case STRING:
            value = string();
                                           isStringValue = true;
            break;
          default:
            jj_la1[48] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          label_34:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case BLANK:
              ;
              break;
            default:
              jj_la1[49] = jj_gen;
              break label_34;
            }
            jj_consume_token(BLANK);
          }
          break;
        default:
          jj_la1[50] = jj_gen;
          ;
        }
        jj_consume_token(RBRACE);
      } catch (ParseException e) {
        errorRecover(e, "f: attrib(), selector's attribute", NL, COMMA, LBRACE, RBRACE);
        {if (true) return null;}
      } finally {
        // attribute is only required value
        if(attribute!=null)
                {if (true) return rf.createAttribute(value, isStringValue, op, attribute);}

        {if (true) return null;}
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Returns pseudopage
 */
  final public Selector.PseudoPage pseudo() throws ParseException {
 /*@bgen(jjtree) pseudo */
        SimpleNode jjtn000 = new SimpleNode(JJTPSEUDO);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);String pseudo = null;
        Selector.PseudoPage function = null;
    try {
      try {
        jj_consume_token(66);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENT:
          pseudo = ident();
          break;
        case FUNCTION:
          function = pfunction();
          break;
        default:
          jj_la1[51] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (ParseException e) {
                errorRecover(e, "f: pseudo(), selector's attribute", BLANK, LBRACE, COMMA);
      } finally {
                // matched first branch
                if(pseudo!=null)
                        {if (true) return rf.createPseudoPage(pseudo, null);}

                {if (true) return function;}
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Returns :pseudo-function() simple selector 
 */
  final public Selector.PseudoPage pfunction() throws ParseException {
 /*@bgen(jjtree) pfunction */
        SimpleNode jjtn000 = new SimpleNode(JJTPFUNCTION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);String functionName = null;
        String value = null;
    try {
      try {
        functionName = function_begin();
        label_35:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case BLANK:
            ;
            break;
          default:
            jj_la1[52] = jj_gen;
            break label_35;
          }
          jj_consume_token(BLANK);
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENT:
          value = ident();
          label_36:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case BLANK:
              ;
              break;
            default:
              jj_la1[53] = jj_gen;
              break label_36;
            }
            jj_consume_token(BLANK);
          }
          break;
        default:
          jj_la1[54] = jj_gen;
          ;
        }
        jj_consume_token(RPAREN);
      } catch (ParseException e) {
                errorRecover(e, "f: pfunction(), selector's attribute", RPAREN, NL, COMMA, LBRACE);
                functionName = null;
      } finally {
                if(functionName!=null) {
                        {if (true) return rf.createPseudoPage(value, functionName);}
                }
                {if (true) return null;}
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Returns operator between terms
 */
  final public Term.Operator operator() throws ParseException {
 /*@bgen(jjtree) operator */
        SimpleNode jjtn000 = new SimpleNode(JJTOPERATOR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Term.Operator op = Term.Operator.SPACE;
    try {
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
        case 69:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 69:
            op = slash();
            label_37:
            while (true) {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case BLANK:
                ;
                break;
              default:
                jj_la1[55] = jj_gen;
                break label_37;
              }
              jj_consume_token(BLANK);
            }
                                                  {if (true) return op;}
            break;
          case COMMA:
            op = comma();
            label_38:
            while (true) {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case BLANK:
                ;
                break;
              default:
                jj_la1[56] = jj_gen;
                break label_38;
              }
              jj_consume_token(BLANK);
            }
                                                  {if (true) return op;}
            break;
          default:
            jj_la1[57] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[58] = jj_gen;
          ;
        }
                  {if (true) return op;}
      } catch (ParseException e) {
                errorRecover(e, "operator(), term's connection", RCURLY, SEMICOLON, BLANK);
                {if (true) return Term.Operator.SPACE;}
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
        {if (true) return op;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Returns combinator between selectors
 */
  final public Selector.Combinator combinator() throws ParseException {
 /*@bgen(jjtree) combinator */
        SimpleNode jjtn000 = new SimpleNode(JJTCOMBINATOR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Selector.Combinator c = Selector.Combinator.DESCENDANT;
    try {
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PLUS:
          c = plus();
          label_39:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case BLANK:
              ;
              break;
            default:
              jj_la1[59] = jj_gen;
              break label_39;
            }
            jj_consume_token(BLANK);
          }
                                      jjtree.closeNodeScope(jjtn000, true);
                                      jjtc000 = false;
                                      {if (true) return c;}
          break;
        case GREATER:
          c = greater();
          label_40:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case BLANK:
              ;
              break;
            default:
              jj_la1[60] = jj_gen;
              break label_40;
            }
            jj_consume_token(BLANK);
          }
                                         jjtree.closeNodeScope(jjtn000, true);
                                         jjtc000 = false;
                                        {if (true) return c;}
          break;
        case BLANK:
          jj_consume_token(BLANK);
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                         {if (true) return c;}
          break;
        default:
          jj_la1[61] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (ParseException e) {
                errorRecover(e, "f: combinator(), selector's connection", LCURLY, BLANK, COMMA);
                {if (true) return Selector.Combinator.DESCENDANT;}
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * If unary operator is found, returns value
 * which is used to multiply current numeric value
 * @return <code>-1</code> for <code>minus</code>
 * and <code>1</code> for <code>plus</code>
 */
  final public int unary_operator() throws ParseException {
 /*@bgen(jjtree) unary_operator */
  SimpleNode jjtn000 = new SimpleNode(JJTUNARY_OPERATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MINUS:
        minus();
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                  {if (true) return -1;}
        break;
      case PLUS:
        plus();
                                          jjtree.closeNodeScope(jjtn000, true);
                                          jjtc000 = false;
                                          {if (true) return 1;}
        break;
      default:
        jj_la1[62] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Return true if priority !important found
 * @return <code>true</code> if node found
 */
  final public boolean prio() throws ParseException {
 /*@bgen(jjtree) prio */
  SimpleNode jjtn000 = new SimpleNode(JJTPRIO);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(IMPORTANT_SYM);
      label_41:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BLANK:
          ;
          break;
        default:
          jj_la1[63] = jj_gen;
          break label_41;
        }
        jj_consume_token(BLANK);
      }
                               jjtree.closeNodeScope(jjtn000, true);
                               jjtc000 = false;
                               {if (true) return true;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Returns list of terms
 * @return List of terms
 */
  final public List<Term<?>> expr() throws ParseException {
 /*@bgen(jjtree) expr */
        SimpleNode jjtn000 = new SimpleNode(JJTEXPR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);List<Term<?>> terms = new ArrayList<Term<?>>();
        Term.Operator op = null;
        Term<?> term = null;
    try {
      try {
        term = term();
                        if(term!=null) {
                                term.setOperator(op);
                                terms.add(term);
                        }
        label_42:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case PLUS:
          case MINUS:
          case COMMA:
          case STRING:
          case IDENT:
          case HASH:
          case EMS:
          case EXS:
          case LENGTHPX:
          case LENGTHCM:
          case LENGTHMM:
          case LENGTHPT:
          case LENGTHPC:
          case ANGLEDEG:
          case ANGLERAD:
          case ANGLEGRAD:
          case TIMEMS:
          case TIMES:
          case FREQHZ:
          case FREQKHZ:
          case PERCENTAGE:
          case NUMBER:
          case URI:
          case FUNCTION:
          case 69:
            ;
            break;
          default:
            jj_la1[64] = jj_gen;
            break label_42;
          }
          op = operator();
          term = term();
                                if(term!=null) {
                                        term.setOperator(op);
                                        terms.add(term);
                                }
        }
      } catch (ParseException e) {
                errorRecover(e, "f: expr(), set of terms", SEMICOLON, NL);
      } finally {
                // do not return terms if there are no terms
                if(terms.isEmpty()) {if (true) return null;}

                // otherwise return all parsed terms
                if(log.isTraceEnabled()) {
                        log.trace("Total terms returned for expression: " + terms.size());
                }
                {if (true) return terms;}
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Returns term (function, color, number, percent, string, identificator)
 */
  final public Term<?> term() throws ParseException {
 /*@bgen(jjtree) term */
        SimpleNode jjtn000 = new SimpleNode(JJTTERM);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Term<?> term = null;
        int unary = 1;
        String value = null;
    try {
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PLUS:
        case MINUS:
        case EMS:
        case EXS:
        case LENGTHPX:
        case LENGTHCM:
        case LENGTHMM:
        case LENGTHPT:
        case LENGTHPC:
        case ANGLEDEG:
        case ANGLERAD:
        case ANGLEGRAD:
        case TIMEMS:
        case TIMES:
        case FREQHZ:
        case FREQKHZ:
        case PERCENTAGE:
        case NUMBER:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case PLUS:
          case MINUS:
            unary = unary_operator();
            break;
          default:
            jj_la1[65] = jj_gen;
            ;
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case NUMBER:
            value = number();
            label_43:
            while (true) {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case BLANK:
                ;
                break;
              default:
                jj_la1[66] = jj_gen;
                break label_43;
              }
              jj_consume_token(BLANK);
            }
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                        // this will create either TermInteger or TermNumber
                                        term = tf.createNumeric(value, unary);
            break;
          case PERCENTAGE:
            value = percentage();
            label_44:
            while (true) {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case BLANK:
                ;
                break;
              default:
                jj_la1[67] = jj_gen;
                break label_44;
              }
              jj_consume_token(BLANK);
            }
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                        term = tf.createPercent(value, unary);
            break;
          case LENGTHPX:
            value = lengthpx();
            label_45:
            while (true) {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case BLANK:
                ;
                break;
              default:
                jj_la1[68] = jj_gen;
                break label_45;
              }
              jj_consume_token(BLANK);
            }
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                        term = tf.createLength(value, TermNumeric.Unit.px, unary);
            break;
          case LENGTHCM:
            value = lengthcm();
            label_46:
            while (true) {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case BLANK:
                ;
                break;
              default:
                jj_la1[69] = jj_gen;
                break label_46;
              }
              jj_consume_token(BLANK);
            }
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                        term = tf.createLength(value, TermNumeric.Unit.cm, unary);
            break;
          case LENGTHMM:
            value = lengthmm();
            label_47:
            while (true) {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case BLANK:
                ;
                break;
              default:
                jj_la1[70] = jj_gen;
                break label_47;
              }
              jj_consume_token(BLANK);
            }
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                        term = tf.createLength(value, TermNumeric.Unit.mm, unary);
            break;
          case LENGTHPT:
            value = lengthpt();
            label_48:
            while (true) {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case BLANK:
                ;
                break;
              default:
                jj_la1[71] = jj_gen;
                break label_48;
              }
              jj_consume_token(BLANK);
            }
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                                term = tf.createLength(value, TermNumeric.Unit.pt, unary);
            break;
          case LENGTHPC:
            value = lengthpc();
            label_49:
            while (true) {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case BLANK:
                ;
                break;
              default:
                jj_la1[72] = jj_gen;
                break label_49;
              }
              jj_consume_token(BLANK);
            }
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                                term = tf.createLength(value, TermNumeric.Unit.pc, unary);
            break;
          case EMS:
            value = ems();
            label_50:
            while (true) {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case BLANK:
                ;
                break;
              default:
                jj_la1[73] = jj_gen;
                break label_50;
              }
              jj_consume_token(BLANK);
            }
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                                term = tf.createLength(value, TermNumeric.Unit.em, unary);
            break;
          case EXS:
            value = exs();
            label_51:
            while (true) {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case BLANK:
                ;
                break;
              default:
                jj_la1[74] = jj_gen;
                break label_51;
              }
              jj_consume_token(BLANK);
            }
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                                term = tf.createLength(value, TermNumeric.Unit.ex, unary);
            break;
          case ANGLEDEG:
            value = angledeg();
            label_52:
            while (true) {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case BLANK:
                ;
                break;
              default:
                jj_la1[75] = jj_gen;
                break label_52;
              }
              jj_consume_token(BLANK);
            }
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                                term = tf.createAngle(value, TermNumeric.Unit.deg, unary);
            break;
          case ANGLERAD:
            value = anglerad();
            label_53:
            while (true) {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case BLANK:
                ;
                break;
              default:
                jj_la1[76] = jj_gen;
                break label_53;
              }
              jj_consume_token(BLANK);
            }
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                                term = tf.createAngle(value, TermNumeric.Unit.rad, unary);
            break;
          case ANGLEGRAD:
            value = anglegrad();
            label_54:
            while (true) {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case BLANK:
                ;
                break;
              default:
                jj_la1[77] = jj_gen;
                break label_54;
              }
              jj_consume_token(BLANK);
            }
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                                term = tf.createAngle(value, TermNumeric.Unit.grad, unary);
            break;
          case TIMEMS:
            value = timems();
            label_55:
            while (true) {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case BLANK:
                ;
                break;
              default:
                jj_la1[78] = jj_gen;
                break label_55;
              }
              jj_consume_token(BLANK);
            }
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                                term = tf.createTime(value, TermNumeric.Unit.ms, unary);
            break;
          case TIMES:
            value = times();
            label_56:
            while (true) {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case BLANK:
                ;
                break;
              default:
                jj_la1[79] = jj_gen;
                break label_56;
              }
              jj_consume_token(BLANK);
            }
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                                term = tf.createTime(value, TermNumeric.Unit.s, unary);
            break;
          case FREQHZ:
            value = freqhz();
            label_57:
            while (true) {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case BLANK:
                ;
                break;
              default:
                jj_la1[80] = jj_gen;
                break label_57;
              }
              jj_consume_token(BLANK);
            }
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                                term = tf.createFrequency(value, TermNumeric.Unit.hz, unary);
            break;
          case FREQKHZ:
            value = freqkhz();
            label_58:
            while (true) {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case BLANK:
                ;
                break;
              default:
                jj_la1[81] = jj_gen;
                break label_58;
              }
              jj_consume_token(BLANK);
            }
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                                term = tf.createFrequency(value, TermNumeric.Unit.khz, unary);
            break;
          default:
            jj_la1[82] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        case STRING:
          value = string();
          label_59:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case BLANK:
              ;
              break;
            default:
              jj_la1[83] = jj_gen;
              break label_59;
            }
            jj_consume_token(BLANK);
          }
                                                  jjtree.closeNodeScope(jjtn000, true);
                                                  jjtc000 = false;
                                              term = tf.createString(value);
          break;
        case IDENT:
          value = ident();
          label_60:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case BLANK:
              ;
              break;
            default:
              jj_la1[84] = jj_gen;
              break label_60;
            }
            jj_consume_token(BLANK);
          }
                                             jjtree.closeNodeScope(jjtn000, true);
                                             jjtc000 = false;
                                             term = tf.createIdent(value);
          break;
        case URI:
          value = uri();
          label_61:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case BLANK:
              ;
              break;
            default:
              jj_la1[85] = jj_gen;
              break label_61;
            }
            jj_consume_token(BLANK);
          }
                                           jjtree.closeNodeScope(jjtn000, true);
                                           jjtc000 = false;
                                           term = tf.createURI(value);
          break;
        case HASH:
          value = hexcolor();
                                     jjtree.closeNodeScope(jjtn000, true);
                                     jjtc000 = false;
                                     term = tf.createColor(value);
          break;
        case FUNCTION:
          term = function();
          break;
        default:
          jj_la1[86] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (ParseException e) {
                errorRecover(e, "f: term(), fast skipping", FAST_SKIP);
                {if (true) return null;}
      } catch (IllegalArgumentException e) {
                if(log.isInfoEnabled())
                        log.info("Failed to set term: ", e);
                {if (true) return null;}
      } finally {
                // check color and replace
                Term<?> colorTerm = null;
                if(term instanceof TermIdent) {
                        colorTerm = tf.createColor((TermIdent)term);
                        if (colorTerm != null)
                                term = colorTerm;
                }
                else if(term instanceof TermFunction) {
                        colorTerm = tf.createColor((TermFunction)term);
                        if(colorTerm != null)
                                term = colorTerm;
                }

                /*
   		if(log.isTraceEnabled()) {
   			log.trace("Having term: " + term + ", value: " 
   				+ "(" + unary + ")"+ value);
   		}
   		*/
                {if (true) return term;}
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Returns function
 */
  final public TermFunction function() throws ParseException {
 /*@bgen(jjtree) function */
        SimpleNode jjtn000 = new SimpleNode(JJTFUNCTION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);String functionName = null;
        List<Term<?>> terms = null;
        TermFunction function = tf.createFunction();
    try {
      try {
        functionName = function_begin();
                                if(functionName!=null)
                                        function.setFunctionName(functionName);
        label_62:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case BLANK:
            ;
            break;
          default:
            jj_la1[87] = jj_gen;
            break label_62;
          }
          jj_consume_token(BLANK);
        }
        terms = expr();
                                function.setValue(terms);
        jj_consume_token(RPAREN);
        label_63:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case BLANK:
            ;
            break;
          default:
            jj_la1[88] = jj_gen;
            break label_63;
          }
          jj_consume_token(BLANK);
        }
      } catch (ParseException e) {
                errorRecover(e, "f: function()", BLANK, SEMICOLON, RPAREN);
      } finally {
                if(log.isTraceEnabled()) {
                        log.trace("Matched function: " + function);
                }
                {if (true) return function;}
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Unary minus
 */
  final public String minus() throws ParseException {
 /*@bgen(jjtree) minus */
  SimpleNode jjtn000 = new SimpleNode(JJTMINUS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(MINUS);
                                          jjtree.closeNodeScope(jjtn000, true);
                                          jjtc000 = false;
                                  {if (true) return t.image;}
    } finally {
                 if (jjtc000) {
                   jjtree.closeNodeScope(jjtn000, true);
                 }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Name of function
 */
  final public String function_begin() throws ParseException {
 /*@bgen(jjtree) function_begin */
  SimpleNode jjtn000 = new SimpleNode(JJTFUNCTION_BEGIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(FUNCTION);
                                          jjtree.closeNodeScope(jjtn000, true);
                                          jjtc000 = false;
                                  {if (true) return t.image.substring(0,t.image.length()-1);}
    } finally {
                 if (jjtc000) {
                   jjtree.closeNodeScope(jjtn000, true);
                 }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Selector operator
 */
  final public Selector.Operator equal() throws ParseException {
 /*@bgen(jjtree) equal */
  SimpleNode jjtn000 = new SimpleNode(JJTEQUAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(EQUAL);
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                  {if (true) return Selector.Operator.EQUALS;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Selector operator
 */
  final public Selector.Operator includes() throws ParseException {
 /*@bgen(jjtree) includes */
  SimpleNode jjtn000 = new SimpleNode(JJTINCLUDES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(INCLUDES);
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                          {if (true) return Selector.Operator.INCLUDES;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Selector operator
 */
  final public Selector.Operator dashmatch() throws ParseException {
 /*@bgen(jjtree) dashmatch */
  SimpleNode jjtn000 = new SimpleNode(JJTDASHMATCH);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(DASHMATCH);
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                   {if (true) return Selector.Operator.DASHMATCH;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Operator comma for terms
 */
  final public Term.Operator comma() throws ParseException {
 /*@bgen(jjtree) comma */
  SimpleNode jjtn000 = new SimpleNode(JJTCOMMA);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(COMMA);
               jjtree.closeNodeScope(jjtn000, true);
               jjtc000 = false;
               {if (true) return Term.Operator.COMMA;}
    } finally {
       if (jjtc000) {
         jjtree.closeNodeScope(jjtn000, true);
       }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Operator slash for terms
 */
  final public Term.Operator slash() throws ParseException {
 /*@bgen(jjtree) slash */
  SimpleNode jjtn000 = new SimpleNode(JJTSLASH);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(69);
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
           {if (true) return Term.Operator.SLASH;}
    } finally {
       if (jjtc000) {
         jjtree.closeNodeScope(jjtn000, true);
       }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Returns text represenatation of hex color
 */
  final public String hexcolor() throws ParseException {
 /*@bgen(jjtree) hexcolor */
        SimpleNode jjtn000 = new SimpleNode(JJTHEXCOLOR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);String hex = null;
    try {
      hex = hash();
      label_64:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BLANK:
          ;
          break;
        default:
          jj_la1[89] = jj_gen;
          break label_64;
        }
        jj_consume_token(BLANK);
      }
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtc000 = false;
                            {if (true) return hex;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Identificator
 * @return Text name of identificator
 */
  final public String ident() throws ParseException {
 /*@bgen(jjtree) ident */
  SimpleNode jjtn000 = new SimpleNode(JJTIDENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(IDENT);
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                             {if (true) return t.image;}
    } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * String value
 */
  final public String string() throws ParseException {
 /*@bgen(jjtree) string */
  SimpleNode jjtn000 = new SimpleNode(JJTSTRING);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(STRING);
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                            {if (true) return t.image.substring(1,t.image.length()-1);}
    } finally {
                 if (jjtc000) {
                   jjtree.closeNodeScope(jjtn000, true);
                 }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * URI value
 */
  final public String uri() throws ParseException {
 /*@bgen(jjtree) uri */
  SimpleNode jjtn000 = new SimpleNode(JJTURI);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(URI);
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                          {if (true) return t.image.substring(3,t.image.length()-1);}
    } finally {
                 if (jjtc000) {
                   jjtree.closeNodeScope(jjtn000, true);
                 }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * String or URI value
 */
  final public String string_or_uri() throws ParseException {
 /*@bgen(jjtree) string_or_uri */
        SimpleNode jjtn000 = new SimpleNode(JJTSTRING_OR_URI);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);String value = null;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING:
        value = string();
                           jjtree.closeNodeScope(jjtn000, true);
                           jjtc000 = false;
                           {if (true) return value;}
        break;
      case URI:
        value = uri();
                                                            jjtree.closeNodeScope(jjtn000, true);
                                                            jjtc000 = false;
                                                            {if (true) return value;}
        break;
      default:
        jj_la1[90] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Numerical value
 */
  final public String number() throws ParseException {
 /*@bgen(jjtree) number */
  SimpleNode jjtn000 = new SimpleNode(JJTNUMBER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(NUMBER);
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                            {if (true) return t.image;}
    } finally {
                 if (jjtc000) {
                   jjtree.closeNodeScope(jjtn000, true);
                 }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Percentage value
 */
  final public String percentage() throws ParseException {
 /*@bgen(jjtree) percentage */
  SimpleNode jjtn000 = new SimpleNode(JJTPERCENTAGE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(PERCENTAGE);
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                {if (true) return t.image;}
    } finally {
                 if (jjtc000) {
                   jjtree.closeNodeScope(jjtn000, true);
                 }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Lenght in pixels
 */
  final public String lengthpx() throws ParseException {
 /*@bgen(jjtree) lengthpx */
  SimpleNode jjtn000 = new SimpleNode(JJTLENGTHPX);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(LENGTHPX);
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                              {if (true) return t.image;}
    } finally {
                 if (jjtc000) {
                   jjtree.closeNodeScope(jjtn000, true);
                 }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Lenght in centimeters
 */
  final public String lengthcm() throws ParseException {
 /*@bgen(jjtree) lengthcm */
  SimpleNode jjtn000 = new SimpleNode(JJTLENGTHCM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(LENGTHCM);
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                              {if (true) return t.image;}
    } finally {
                 if (jjtc000) {
                   jjtree.closeNodeScope(jjtn000, true);
                 }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Lenght in milimeters
 */
  final public String lengthmm() throws ParseException {
 /*@bgen(jjtree) lengthmm */
  SimpleNode jjtn000 = new SimpleNode(JJTLENGTHMM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(LENGTHMM);
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                              {if (true) return t.image;}
    } finally {
                 if (jjtc000) {
                   jjtree.closeNodeScope(jjtn000, true);
                 }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Length in point size
 */
  final public String lengthpt() throws ParseException {
 /*@bgen(jjtree) lengthpt */
  SimpleNode jjtn000 = new SimpleNode(JJTLENGTHPT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(LENGTHPT);
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                              {if (true) return t.image;}
    } finally {
                 if (jjtc000) {
                   jjtree.closeNodeScope(jjtn000, true);
                 }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Lenght in pc
 */
  final public String lengthpc() throws ParseException {
 /*@bgen(jjtree) lengthpc */
  SimpleNode jjtn000 = new SimpleNode(JJTLENGTHPC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(LENGTHPC);
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                              {if (true) return t.image;}
    } finally {
                 if (jjtc000) {
                   jjtree.closeNodeScope(jjtn000, true);
                 }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Length in ems
 */
  final public String ems() throws ParseException {
 /*@bgen(jjtree) ems */
  SimpleNode jjtn000 = new SimpleNode(JJTEMS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(EMS);
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                          {if (true) return t.image;}
    } finally {
                 if (jjtc000) {
                   jjtree.closeNodeScope(jjtn000, true);
                 }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Lenght in exs
 */
  final public String exs() throws ParseException {
 /*@bgen(jjtree) exs */
  SimpleNode jjtn000 = new SimpleNode(JJTEXS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(EXS);
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                          {if (true) return t.image;}
    } finally {
                 if (jjtc000) {
                   jjtree.closeNodeScope(jjtn000, true);
                 }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Length in deg	
 */
  final public String angledeg() throws ParseException {
 /*@bgen(jjtree) angledeg */
  SimpleNode jjtn000 = new SimpleNode(JJTANGLEDEG);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(ANGLEDEG);
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                              {if (true) return t.image;}
    } finally {
                 if (jjtc000) {
                   jjtree.closeNodeScope(jjtn000, true);
                 }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Length in rad
 */
  final public String anglerad() throws ParseException {
 /*@bgen(jjtree) anglerad */
  SimpleNode jjtn000 = new SimpleNode(JJTANGLERAD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(ANGLERAD);
                              jjtree.closeNodeScope(jjtn000, true);
                              jjtc000 = false;
                              {if (true) return t.image;}
    } finally {
                 if (jjtc000) {
                   jjtree.closeNodeScope(jjtn000, true);
                 }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Length in grad
 */
  final public String anglegrad() throws ParseException {
 /*@bgen(jjtree) anglegrad */
  SimpleNode jjtn000 = new SimpleNode(JJTANGLEGRAD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(ANGLEGRAD);
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                               {if (true) return t.image;}
    } finally {
                 if (jjtc000) {
                   jjtree.closeNodeScope(jjtn000, true);
                 }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Time in milliseconds
 */
  final public String timems() throws ParseException {
 /*@bgen(jjtree) timems */
  SimpleNode jjtn000 = new SimpleNode(JJTTIMEMS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(TIMEMS);
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                            {if (true) return t.image;}
    } finally {
                 if (jjtc000) {
                   jjtree.closeNodeScope(jjtn000, true);
                 }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Time in seconds
 */
  final public String times() throws ParseException {
 /*@bgen(jjtree) times */
  SimpleNode jjtn000 = new SimpleNode(JJTTIMES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(TIMES);
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                           {if (true) return t.image;}
    } finally {
                 if (jjtc000) {
                   jjtree.closeNodeScope(jjtn000, true);
                 }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Frequency in Hz
 */
  final public String freqhz() throws ParseException {
 /*@bgen(jjtree) freqhz */
  SimpleNode jjtn000 = new SimpleNode(JJTFREQHZ);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(FREQHZ);
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                            {if (true) return t.image;}
    } finally {
                 if (jjtc000) {
                   jjtree.closeNodeScope(jjtn000, true);
                 }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Frequency in kHz
 */
  final public String freqkhz() throws ParseException {
 /*@bgen(jjtree) freqkhz */
  SimpleNode jjtn000 = new SimpleNode(JJTFREQKHZ);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(FREQKHZ);
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                  {if (true) return t.image;}
    } finally {
                 if (jjtc000) {
                   jjtree.closeNodeScope(jjtn000, true);
                 }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Hash-prefixed value
 */
  final public String hash() throws ParseException {
 /*@bgen(jjtree) hash */
  SimpleNode jjtn000 = new SimpleNode(JJTHASH);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(HASH);
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                  {if (true) return t.image;}
    } finally {
                 if (jjtc000) {
                   jjtree.closeNodeScope(jjtn000, true);
                 }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Returns plus combinator
 */
  final public Selector.Combinator plus() throws ParseException {
 /*@bgen(jjtree) plus */
  SimpleNode jjtn000 = new SimpleNode(JJTPLUS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(PLUS);
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                    {if (true) return Selector.Combinator.ADJACENT;}
    } finally {
            if (jjtc000) {
              jjtree.closeNodeScope(jjtn000, true);
            }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Returns greater combinator
 */
  final public Selector.Combinator greater() throws ParseException {
 /*@bgen(jjtree) greater */
  SimpleNode jjtn000 = new SimpleNode(JJTGREATER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(GREATER);
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                 {if (true) return Selector.Combinator.CHILD;}
    } finally {
       if (jjtc000) {
         jjtree.closeNodeScope(jjtn000, true);
       }
    }
    throw new Error("Missing return statement in function");
  }

  public CSSParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[91];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_0();
      jj_la1_1();
      jj_la1_2();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x0,0x1c00000,0x1c00000,0x0,0x1c00000,0x1c00000,0x80000000,0x80000000,0x1c00000,0x1c00000,0x400000,0x400000,0x0,0x0,0x400000,0x0,0x400000,0x0,0x400000,0x400000,0x80000000,0x400000,0x0,0x400000,0x400000,0x0,0x400000,0x400000,0x400000,0x0,0x400000,0x0,0x400000,0x400000,0x0,0x0,0x400000,0x400000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x0,0x400000,0x400000,0xe000000,0x400000,0x0,0x400000,0xe000000,0x0,0x400000,0x400000,0x0,0x400000,0x400000,0x0,0x0,0x400000,0x400000,0x400000,0x0,0x400000,0x0,0x0,0x400000,0x400000,0x400000,0x400000,0x400000,0x400000,0x400000,0x400000,0x400000,0x400000,0x400000,0x400000,0x400000,0x400000,0x400000,0x400000,0x0,0x400000,0x400000,0x400000,0x0,0x400000,0x400000,0x400000,0x0,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x2000,0x0,0x0,0x400,0x0,0x0,0x1b00,0x1b00,0x0,0x0,0x0,0x0,0x40,0x20,0x0,0x100,0x0,0x20,0x0,0x0,0x300,0x0,0x20,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x4000,0x100,0x0,0x14,0x200,0x200,0x200,0x200,0x300,0x100,0x0,0x0,0x0,0x0,0x140,0x0,0x0,0x100,0x0,0x0,0x100,0x0,0x0,0x20,0x20,0x0,0x0,0x14,0xc,0x0,0xdfff836c,0xc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xdfff8000,0x0,0x0,0x0,0xdfff834c,0x0,0x0,0x0,0x40,};
   }
   private static void jj_la1_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x1c,0x1c,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc,0xc,0xc,0xc,0x1c,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x20,0x20,0x0,0x0,0x0,0x0,0x0,0x23,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x1,};
   }

  public CSSParser(java.io.InputStream stream) {
     this(stream, null);
  }
  public CSSParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new CSSParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 91; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 91; i++) jj_la1[i] = -1;
  }

  public CSSParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new CSSParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 91; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 91; i++) jj_la1[i] = -1;
  }

  public CSSParser(CSSParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 91; i++) jj_la1[i] = -1;
  }

  public void ReInit(CSSParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 91; i++) jj_la1[i] = -1;
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[70];
    for (int i = 0; i < 70; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 91; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 70; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

}
