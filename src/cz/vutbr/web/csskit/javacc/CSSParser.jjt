/* Options for generated parser */
options {
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = true;
  IGNORE_CASE = true;
  STATIC = false;
}


/* API definition */
PARSER_BEGIN(CSSParser)

package cz.vutbr.web.csskit.javacc;

import java.io.Reader;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.HashSet;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import cz.vutbr.web.css.CSSFactory;
import cz.vutbr.web.css.CombinedSelector;
import cz.vutbr.web.css.Declaration;
import cz.vutbr.web.css.RuleImport;
import cz.vutbr.web.css.Rule;
import cz.vutbr.web.css.RuleBlock;
import cz.vutbr.web.css.RuleBlock.Priority;
import cz.vutbr.web.css.RuleFactory;
import cz.vutbr.web.css.RuleMedia;
import cz.vutbr.web.css.RulePage;
import cz.vutbr.web.css.RuleSet;
import cz.vutbr.web.css.Selector;
import cz.vutbr.web.css.StyleSheet;
import cz.vutbr.web.css.CSSException;
import cz.vutbr.web.css.Term;
import cz.vutbr.web.css.TermFactory;
import cz.vutbr.web.css.TermFunction;
import cz.vutbr.web.css.TermIdent;
import cz.vutbr.web.css.TermNumeric;

import cz.vutbr.web.csskit.PriorityStrategy;

/**
 * Parser of CSS passed as InputStream, Reader or directly as String.
 * Successful parsing creates StyleSheet  	
 */
//@SuppressWarnings("all")
public class CSSParser {
	
	private static Logger log = LoggerFactory.getLogger(CSSParser.class);

	private static final TermFactory tf = CSSFactory.getTermFactory();
	private static final RuleFactory rf = CSSFactory.getRuleFactory();

	 /**
      * This flag causes skipping of token with checking for 
      * type of next token. Use it with errorRecover function
      * Note:
      * This negative value should be never identification of token
      */
    private static final int FAST_SKIP = -10;


    // priority using integer value
	private static final class PriorityImpl implements Priority {		
		final int priority;
		public PriorityImpl(int priority) { this.priority = priority; }
		
		public int compareTo(Priority o) {
			if(!(o instanceof PriorityImpl))
				throw new ClassCastException("Unable to compare with different instance of priority: " + o.getClass());
			PriorityImpl other = (PriorityImpl) o;		
			return this.priority - other.priority;
		}
		
		@Override
		public String toString() {
			return String.valueOf(priority);
		}
	}

	private PriorityStrategy ps = new PriorityStrategy() {
		int counter = 0;
	    public Priority getAndIncrement() {
	    	return new PriorityImpl(counter++);
	    }
	    public Priority markAndIncrement() {
	    	return new PriorityImpl(counter++);
	    }
   };	

	/** Character set of given css */
	private String charset;
	
	/** Rules gathered from input */
	private List<RuleBlock<?>> rules = new ArrayList<RuleBlock<?>>();		
		
	/**
	 * Error recovery.
	 * Skip to given token in case of error.
	 * End of File (EOF) token is added automatically.
	 * @param e Exception to be logged  
	 * @param message message to be logged
	 * @param kinds Type(s) of token where to continue, if <code>null</code> do not skip anything  
	 */
	private void errorRecover(final ParseException exception, final String message, final int...kinds) {
	
		if(log.isInfoEnabled()) {
			if(log.isDebugEnabled()) {
				log.debug(message, exception);
			}
			else {	
				log.info(message);
			}
		}
		
		// don't do skipping
		if(kinds.length==0) return;
		
	
	    // use auto boxing and unboxing, not very pretty 
		// construct stop tokens
		// array list should be faster for this situation
		Set<Integer>  stopTokens = new HashSet<Integer>(kinds.length + 1);
		for(int i = 0; i < kinds.length; i++)
			stopTokens.add(new Integer(kinds[i]));
			
		stopTokens.add(EOF); 
	
		// TODO: is this appropriate behavior?
		boolean first = true;
		Token t;
		do {
			t = getNextToken();
			if(first) {
				if(log.isTraceEnabled()) {
					log.trace("Failed on token: " +
					CSSParserConstants.tokenImage[t.kind] +
					" = " + t.image);
					first = false; 
				}
			}
		}while(!(stopTokens.contains(t.kind) || stopTokens.contains(FAST_SKIP)));
	
		if(log.isTraceEnabled()) {
			log.trace("Recovered on token: " + CSSParserConstants.tokenImage[t.kind] + " = " + t.image );
		}	
		
	}

}
PARSER_END(CSSParser)

// Skip comments
SKIP :
{
  <SLASH_STAR_COMMENT: "/*" (~["*"])* ("*")+ (~["/","*"] (~["*"])* ("*")+)* "/" >
}

// Tokens of lexical analyzer 
TOKEN : 
{
  <#h : ["0"-"9", "a"-"f"]> |
  <#nonascii : ["\200"-"\377"]> |
  <#unicode : "\\" <h> (<h>)? (<h>)? (<h>)? (<h>)? (<h>)? ("\r\n"|[" ", "\t", "\r", "\n", "\f"])? > |
  <#escape : <unicode> | "\\" ~["\r", "\n", "\f", "0"-"9", "a"-"f"]> |
  <#nmstart : ["_", "a"-"z"] | <nonascii> | <escape>> |
  <#nmchar : ["_", "a"-"z", "0"-"9", "-"] | <nonascii> | <escape>> |
  <#string1 : "\"" (~["\n", "\r", "\f", "\""] | "\\" <NL> | <escape>)* "\""> |
  <#string2 : "'" (~["\n", "\r", "\f", "'"] | "\\" <NL> | <escape>)* "'"> |
  <#invalid1 : "\""(~["\n", "\r", "\f", "\""] | "\\" <NL> | <escape>)* > |
  <#invalid2	: "'"(~["\n", "\r", "\f", "'"] | "\\" <NL> | <escape>)* > |

  <#comment : "/*" (~["*"])* ("*")+ (~["/","*"] (~["*"])* ("*")+)* "/" > |
  <#ident : ("-")? <nmstart> (<nmchar>)* > |
  <#name : (<nmchar>)+ > |
  <#num : (["0"-"9"])+ | (["0"-"9"])* "." (["0"-"9"])+ > |
  <#string : <string1>|<string2> > |
  <#invalid : <invalid1>|<invalid2> > |
  <#url : ([";", "!", "#", "$", "%", "&", "*", "-", "~", ".", "/", ":", ",", "=", "?"] | <nmchar> )* > | 
  
  <#SPACE : ([" ", "\t", "\r", "\n", "\f"])+ > |
  <#WHITECHAR : (<SPACE>)? > |  
  
  <#NL : "\n" | "\r\n" | "\r" | "\f"> |

  <BLANK : <SPACE> > |

  <CDO : "<!--" > |
  <CDC : "-->" > |
  <EQUAL : "=" > |
  <INCLUDES : "~=" > |
  <DASHMATCH : "|=" > |

  <LCURLY : <WHITECHAR> "{" > |
  <RCURLY : <WHITECHAR> "}" > |
  <RPAREN : ")" > |
  <LBRACE : "[" > |
  <RBRACE : "]" > |
  <SEMICOLON: ";" > |
  <PLUS : <WHITECHAR> "+" > |
  <MINUS : <WHITECHAR> "-" > |
  <GREATER : <WHITECHAR> ">" > |
  <COMMA : <WHITECHAR> "," > |
  <STRING : <string> > |
  <INVALID : <invalid> > |
  <IDENT : <ident> > |

  <HASH : "#" <name> > |

  <IMPORT_SYM : "@import" > |
  <PAGE_SYM : "@page" > |
  <MEDIA_SYM : "@media" > |
  <CHARSET_SYM : "@charset " > |

  <IMPORTANT_SYM : "!" (<WHITECHAR>|<comment>)* "important" > |

  <EMS : <num> "em" > |
  <EXS : <num> "ex" > |
  <LENGTHPX : <num> "px" > | 
  <LENGTHCM : <num> "cm" > | 
  <LENGTHMM : <num> "mm" > | 
  <LENGTHPT : <num> "pt" > | 
  <LENGTHPC : <num> "pc" > |
  <ANGLEDEG : <num> "deg" > | 
  <ANGLERAD : <num> "rad" > |
  <ANGLEGRAD : <num> "grad" > |
  <TIMEMS : <num> "ms" > |
  <TIMES : <num> "s" > |
  <FREQHZ : <num> "hz" > |
  <FREQKHZ : <num> "khz" > | 

  <DIMENSION : <num> <ident> > |

  <PERCENTAGE : <num> "%" > |
  <NUMBER : <num> > |

  <URI : ("url(" <WHITECHAR> <string> <WHITECHAR> <RPAREN>) | ("url("<WHITECHAR> <url> <WHITECHAR> <RPAREN> ) > |
  <FUNCTION : <ident> "(" >
}


/**
 * Parses input and returns gathered information as StyleSheet.
 * @return StyleSheet which contains rules gathered.
 * @see StyleSheet
 */
StyleSheet stylesheet() :
{}
{
	try {
  		( charset() )?
  		(<BLANK> | <CDO> | <CDC>)* 
  		( import_a() (<BLANK> | <CDO> | <CDC> )* )*
  		( 
  			( 	ruleset(rules) | 
  				media() | 
  				page() 
  			) 
  			(<BLANK> | <CDO> | <CDC>)* 
  		)*
  	}
  	catch (ParseException e) {
  		errorRecover(e, "f: stylesheet()");
  	}
  	finally {
  		StyleSheet stylesheet = rf.createStyleSheet();
  		stylesheet.replaceAll(rules);
  
  		return stylesheet; 
  	}
}

/**
 * Internally sets charset of document. 
 */
void charset() :
{String currentCharset = null;}
{
	try {
  		<CHARSET_SYM> currentCharset = string() <SEMICOLON>
  		{
  			charset = currentCharset;
  		}
  	}
  	catch (ParseException e) {
  		// according to CSS UA
  		// ignore until next block is found
  		errorRecover(e, "f: charset(), failed to retrieve", RCURLY);
  	}
}


/**
 * Creates and add new import rule to stylesheet 
 */
void import_a() :
{
	String currentUri = null;
	List<String> medias = new ArrayList<String>();
}
{ 
	try {
  		<IMPORT_SYM> (<BLANK>)*
  		[currentUri=string_or_uri() (<BLANK>)*]	
  		( 
  			medium(medias) 
  			(
  				<COMMA> 
  				(
  					<BLANK>)* 
  					medium(medias)
  				)* 
  			)? 
  			<SEMICOLON> 
  		{	
  			if(currentUri!=null || !"".equals(currentUri)) {
  				RuleImport uri = rf.createImport(ps.getAndIncrement());
  				uri.setURI(currentUri);
  				uri.replaceAll(medias);
  				this.rules.add(uri);	
  			}	
  		}
  	}
  	catch (ParseException e) {
  		errorRecover(e, "f: import_a()", BLANK);
  	}
}

/**
 * Creates and sets new media rule to stylesheet
 */
void media() :
{
	List<String> medias = new ArrayList<String>();
	List<? extends RuleBlock<?>> mediarules = new ArrayList<RuleSet>();
}
{
	try {
  		<MEDIA_SYM> 
  		(<BLANK>)* 
  		medium(medias) 
  		( 
  			<COMMA> 
  			(<BLANK>)* 
  			medium(medias) 
  		)* 
  		<LCURLY> 
  		(<BLANK>)* 
  		(ruleset( (List<RuleBlock<?>>) mediarules))* 
  		<RCURLY> 
  		{
			RuleMedia media = rf.createMedia(ps.getAndIncrement());
  			media.setMedia(medias);
  			media.replaceAll( (List<RuleSet>) mediarules);
  			rules.add(media);
  		}
  	}
  	catch (ParseException e) {
  		errorRecover(e, "f: media()", RCURLY);
  	}
}

/**
 * Adds media to list.
 * @param medias Current list of associated medias
 */
void medium(List<String> medias) :
{
	String currentMedia = null;
}
{
	try {
  		currentMedia = ident() (<BLANK>)*
  		{
  			medias.add(currentMedia);
  		}
  	}
  	catch (ParseException e) {
  		errorRecover(e, "f: medium()", BLANK);
  	}
  	// trying to add the same element more times
  	catch (IllegalArgumentException e) {
		log.warn("Multiple definition of media :" + currentMedia); 
  	}
}

/**
 * Inserts ruleset's rule into rule set
 * @param rules List of rules where new ruleset will be added
 */
void ruleset(List<RuleBlock<?>> rules) :
{
	List<CombinedSelector> cslist = new ArrayList<CombinedSelector>();
	List<Declaration> declarations = new ArrayList<Declaration>();
	
	CombinedSelector cs = null;
	Declaration dec = null;
}
{
	try {
  		cs = combined_selector() 
  		{
  			if(cs!=null) cslist.add(cs);
  		}
  		( <COMMA> (<BLANK>)* cs = combined_selector()
  			{
  				if(cs!=null) cslist.add(cs);
  			} 
  		)*
  		<LCURLY> 
  		(<BLANK>)* dec = declaration()
  			{
  				// store declaration
  				if(dec != null) declarations.add(dec);
  			} 
  			( <SEMICOLON> (<BLANK>)* dec = declaration()
  				{
  					// store another declaration
  					if(dec != null) declarations.add(dec);
  				} 
  			)* 
  		<RCURLY>
  	}
  	catch (ParseException e) {
  		errorRecover(e, "f: ruleset()", RCURLY);
  	}
  	// be error graceful to unknown selectors and declarations
  	finally {
  		if(cslist.size() > 0 && declarations.size() > 0) {
  			RuleSet rule = rf.createSet(ps.getAndIncrement());
  			rule.setSelectors(cslist);
  			rule.replaceAll(declarations);
  			rules.add(rule);
  		}
  	}
}

/**
 * Inserts page rule as stylesheet rule 
 */
void page() :
{
	List<Declaration> declarations = new ArrayList<Declaration>();
	Declaration dec = null;
	String pseudo = null;
}
{
	try {
  		<PAGE_SYM> (<BLANK>)* [ pseudo = pseudo_page() (<BLANK>)*]
    	<LCURLY> 
    	(<BLANK>)* dec = declaration()
    		{
    			// add declaration
    			if(dec != null) declarations.add(dec);
    		} 
    		( <SEMICOLON> (<BLANK>)* dec = declaration()
    			{
    				// add declaration
    				if(dec != null) declarations.add(dec);
    			} 
    		)* 
    	<RCURLY> 
    }
    catch (ParseException e) {
		errorRecover(e, "f: page()", RCURLY);    
    }
    // be error graceful to unknown declarations
  	finally {
  		if(declarations.size() > 0) {
  			RulePage page = rf.createPage(ps.getAndIncrement());
  			page.setPseudo(pseudo);
  			page.replaceAll(declarations);
    		this.rules.add(page);
  		}
  	}
}

/**
 * Retrieve pseudo for page
 * @return Pseudo of current page
 */
String pseudo_page() :
{
	String pseudo = null;
}
{
  ":" pseudo = ident() 
  { 
  	return pseudo;
  }
}

/**
 * Returns new declaration
 * @return declaration
 */
Declaration declaration() :
{
	Declaration declaration = rf.createDeclaration();
	List<Term<?>> terms = null;
	String property = null;
	boolean important = false;
}
{
	try {
  		( property = property() ":" (<BLANK>)* terms = expr() ( important = prio())? )?
  	}
  	catch (ParseException e) {
  		errorRecover(e, "f: declaration()", BLANK, NL, SEMICOLON, RCURLY);
  	}
  	finally {
  		// do not allow improperly filled declaration
  		if(terms==null || property==null)
  		 	return null;
  	
  		declaration.setImportant(important);
		declaration.setProperty(property);
		declaration.replaceAll(terms);
  			
		if(log.isDebugEnabled()) {
			log.debug("Having declaration of property: " + property +
  				", and " + declaration.size() + " terms " + terms);
  		}
  		return declaration;
  	}
}


/**
 * Returns name of property
 * @return Name of property
 */
String property() :
{
	String currentProperty = null;
}
{
  	currentProperty = ident() (<BLANK>)* { return currentProperty;}
}

/**
 * Returns selector for given rules
 * @return CombinedSelector  
 */
CombinedSelector combined_selector() :
{
	CombinedSelector cs = rf.createCombinedSelector();
	List<Selector> list = new ArrayList<Selector>();
	Selector selector = null;
	Selector.Combinator c = null;
}
{
	try {
  		selector=selector()
  			{
  				if(selector!=null) list.add(selector); 
  			} 
  		( 
  			c = combinator() {
  				if(log.isTraceEnabled()) {
  					log.trace("Combinator: " + c);
  				}
  			}
  			selector = selector()
  				{
  					if(selector!=null) {
  						selector.setCombinator(c);
  						list.add(selector);
  					}
  				} 
  		)*
  	}
  	catch(ParseException e) {
  		errorRecover(e, "f: combined_selector()", BLANK, LCURLY);
  	}
  	finally {
  		if(log.isDebugEnabled()) {
  			log.debug("Having selectors(" + list.size() + "): " + list);
  		}
  		cs.replaceAll(list);
  		return cs;
  	}
}

/**
 * Returns selector
 * @return Selector as a part of CombinedSelector
 */
Selector selector() :
{
	Selector selector = (Selector) rf.createSelector().unlock();
	String value = null;
	Selector.SelectorPart item = null;
}
{
	try {
  		value = element_name()
  			{
  				selector.add(rf.createElement(value));
  			} 
  		( 
  			value = hash() 
  				{
  					item = rf.createID(value);
  					if(item != null) selector.add(item);
  			 	} |
  			item = class_a() 
  				{
  					if(item!=null) selector.add(item);
  				} |	 
  			item = attrib() 
  				{
  					if(item!=null) selector.add(item);
  				} | 
  			item = pseudo()  
  				{
  					if(item!=null) selector.add(item);
  				}
  		)*| 
  		( 
  			value = hash()
  			 	{
  					item = rf.createID(value);
  					if(item != null) selector.add(item);
  			 	} |
  			item = class_a() 
  				{
  					if(item!=null) selector.add(item);
  				} |	 
  			item = attrib() 
  				{
  					if(item!=null) selector.add(item);
  				} |	
  			item = pseudo() 
  				{
  					if(item!=null) selector.add(item);
  				}
  		)+
  	}
  	catch(ParseException e) {
  		errorRecover(e, "f: selector()", BLANK, LCURLY);
  	}
  	catch(Exception e) {
  		log.warn("f: selector(): ", e);
  	}
  	finally {
  		if(log.isTraceEnabled()) {
  			log.trace("Returning selector: " + selector);
  		}
  		
  		return selector;
  	}
}

/**
 * Returns .class simple selector
 */
Selector.ElementClass class_a() :
{
	String value = null;
}
{
  "." value = ident() 
  	{ 
  		return rf.createClass(value);
  	}
}

/**
 * Returns name of element for selector.
 * @return Name of element or asterisk
 */
String element_name() :
{
	String element = null;
}
{
  	element=ident() { return element;} | "*" {return "*";}
}

/**
 * Returns [attribute] 
 */
Selector.ElementAttribute attrib() :
{
	String attribute = null;
	String value = null;
	boolean isStringValue = false;	// default value is identificator, so false
	Selector.Operator op = Selector.Operator.NO_OPERATOR;
}
{
	try {
  		<LBRACE> 
  		(
  			<BLANK>)* attribute = ident() (<BLANK>
  		)* 
  		[ 
  			(op = equal() | op = includes() | op = dashmatch() ) (<BLANK>)*
    		( 	
    			value = ident()	{ isStringValue = false; } | 
    			value = string() { isStringValue = true; }
    		) (<BLANK>)* 
    	] 
    	<RBRACE>
    }
    catch (ParseException e) {
    	errorRecover(e, "f: attrib(), selector's attribute", NL, COMMA, LBRACE, RBRACE);
    	return null;
    }
    finally {
    	// attribute is only required value
    	if(attribute!=null)
    		return rf.createAttribute(value, isStringValue, op, attribute);
    	
    	return null;
    }
}

/**
 * Returns pseudopage
 */
Selector.PseudoPage pseudo() :
{
	String pseudo = null;
	Selector.PseudoPage function = null;
}
{
	try {
  		":" 
  		( 
  			pseudo = ident() | 
  			function = pfunction() 
  		)
  	}
  	catch (ParseException e) {
  		errorRecover(e, "f: pseudo(), selector's attribute", BLANK, LBRACE, COMMA); 
  	}
  	finally {
  		// matched first branch
  		if(pseudo!=null) 
  			return rf.createPseudoPage(pseudo, null);
  		
  		return function;
  	}
}

/**
 * Returns :pseudo-function() simple selector 
 */
Selector.PseudoPage pfunction() :
{
	String functionName = null;
	String value = null;
}
{
	try {
  		functionName = function_begin() 
  		(<BLANK>)* 
  		[ value = ident() (<BLANK>)* ] 
  		<RPAREN>
  	}
  	catch (ParseException e) {
  		errorRecover(e, "f: pfunction(), selector's attribute", RPAREN, NL, COMMA, LBRACE);
  		functionName = null;
  	}
  	finally {
  		if(functionName!=null) {
  			return rf.createPseudoPage(value, functionName);
  		}
  		return null;
  	}
}

/**
 * Returns operator between terms
 */
Term.Operator operator() :
{
	Term.Operator op = Term.Operator.SPACE;
}
{
	try {
  		( 
  			op = slash() (<BLANK>)* { return op;} | 
  			op = comma() (<BLANK>)* { return op;} 
  		)?
  		{ return op;}
  	}
  	catch (ParseException e) {
  		errorRecover(e, "operator(), term's connection", RCURLY, SEMICOLON, BLANK);
  		return Term.Operator.SPACE;
  	}
  {
  	return op;
  }
}

/**
 * Returns combinator between selectors
 */
Selector.Combinator combinator() :
{
	Selector.Combinator c = Selector.Combinator.DESCENDANT;
}
{
	try {
  		c=plus() (<BLANK>)* { return c;} | 
  		c=greater() (<BLANK>)* {return c;} | 
  		<BLANK> {return c;}
  	}
  	catch (ParseException e) {
  		errorRecover(e, "f: combinator(), selector's connection", LCURLY, BLANK, COMMA);
  		return Selector.Combinator.DESCENDANT;
  	}
}

/**
 * If unary operator is found, returns value
 * which is used to multiply current numeric value
 * @return <code>-1</code> for <code>minus</code>
 * and <code>1</code> for <code>plus</code>
 */
int unary_operator() :
{}
{
  	minus() { return -1; } | plus() { return 1; }
}

/**
 * Return true if priority !important found
 * @return <code>true</code> if node found
 */
boolean prio() :
{}
{
  <IMPORTANT_SYM> (<BLANK>)* { return true;}
}

/**
 * Returns list of terms
 * @return List of terms
 */
List<Term<?>> expr() :
{
	List<Term<?>> terms = new ArrayList<Term<?>>();
	Term.Operator op = null;
	Term<?> term = null;
}
{
	try {
  		term = term() 
  		{
  			if(term!=null) {
  				term.setOperator(op);
  				terms.add(term);
  			}	
  		}
  		( op = operator() term = term() 
  			{
  				if(term!=null) {
					term.setOperator(op);
					terms.add(term);
				}  				
  			}
  		)*
  	}
  	// even in case of error return currently parsed terms
  	catch (ParseException e) {
  		errorRecover(e, "f: expr(), set of terms", SEMICOLON, NL);
  	}
  	finally {
  		// do not return terms if there are no terms
  		if(terms.isEmpty()) return null;
  		
  		// otherwise return all parsed terms
  		if(log.isTraceEnabled()) {
  			log.trace("Total terms returned for expression: " + terms.size());
  		}
  		return terms;
  	}
}

/**
 * Returns term (function, color, number, percent, string, identificator)
 */
Term<?> term() :
{
	
	Term<?> term = null;
	int unary = 1;
	String value = null;
}
{
	try {
		[ unary = unary_operator() ]
		(	value = number() (<BLANK>)* 
				{
					// this will create either TermInteger or TermNumber
					term = tf.createNumeric(value, unary);	
				} | 
			value = percentage() (<BLANK>)* 
				{
					term = tf.createPercent(value, unary);
				} | 
   			value = lengthpx() (<BLANK>)* 
   				{ 
   					term = tf.createLength(value, TermNumeric.Unit.px, unary); 
   				} | 
   			value = lengthcm() (<BLANK>)* 
   				{
   					term = tf.createLength(value, TermNumeric.Unit.cm, unary);
   				} |  
   			value = lengthmm() (<BLANK>)*
   				{
   					term = tf.createLength(value, TermNumeric.Unit.mm, unary);
   				} | 
	    	value = lengthpt() (<BLANK>)* 
	    		{
	    			term = tf.createLength(value, TermNumeric.Unit.pt, unary);
	    		} | 
    		value = lengthpc() (<BLANK>)* 
    			{
    				term = tf.createLength(value, TermNumeric.Unit.pc, unary);
    			} | 
    		value = ems() (<BLANK>)* 
    			{
    				term = tf.createLength(value, TermNumeric.Unit.em, unary);
    			} | 
    		value = exs() (<BLANK>)* 
    			{
    				term = tf.createLength(value, TermNumeric.Unit.ex, unary);
    			} | 
    		value = angledeg() (<BLANK>)* 
    			{
    				term = tf.createAngle(value, TermNumeric.Unit.deg, unary);
    			} |
    		value = anglerad() (<BLANK>)* 
    			{
    				term = tf.createAngle(value, TermNumeric.Unit.rad, unary);
    			} | 
	    	value = anglegrad() (<BLANK>)* 
	    		{
	    			term = tf.createAngle(value, TermNumeric.Unit.grad, unary);
	    		} |
    		value = timems() (<BLANK>)* 
    			{
    				term = tf.createTime(value, TermNumeric.Unit.ms, unary);
    			} |
    		value = times() (<BLANK>)* 
    			{
    				term = tf.createTime(value, TermNumeric.Unit.s, unary);
    			} | 
    		value = freqhz() (<BLANK>)* 
    			{
    				term = tf.createFrequency(value, TermNumeric.Unit.hz, unary);
    			} | 
    		value = freqkhz() (<BLANK>)* 
    			{
    				term = tf.createFrequency(value, TermNumeric.Unit.khz, unary);
    			}
   		) | 
   		value = string() (<BLANK>)*	{ term = tf.createString(value);	} | 
   		value = ident() (<BLANK>)* { term = tf.createIdent(value); } | 
   		value = uri() (<BLANK>)* { term = tf.createURI(value);} | 
   		value = hexcolor() { term = tf.createColor(value); } | 
   		term = function() 
   		
   	}
   	catch(ParseException e) {
   		errorRecover(e, "f: term(), fast skipping", FAST_SKIP);
   		return null;
   	}
   	catch(IllegalArgumentException e) {
   		if(log.isInfoEnabled()) 
   			log.info("Failed to set term: ", e);  
   		return null;
   	}
   	finally {
   	
   		// check color and replace
   		Term<?> colorTerm = null;
   		if(term instanceof TermIdent) {
   			colorTerm = tf.createColor((TermIdent)term);
   			if (colorTerm != null)
   				term = colorTerm;
   		}
   		else if(term instanceof TermFunction) {
   			colorTerm = tf.createColor((TermFunction)term);
   			if(colorTerm != null)
   				term = colorTerm;
   		}
   		
   		/*
   		if(log.isTraceEnabled()) {
   			log.trace("Having term: " + term + ", value: " 
   				+ "(" + unary + ")"+ value);
   		}
   		*/
   		return term;
   	}
}

/**
 * Returns function
 */
TermFunction function() :
{
	String functionName = null;
	List<Term<?>> terms = null;
	TermFunction function = tf.createFunction();
}
{
	try {
  		functionName = function_begin() 
  			{
  				if(functionName!=null)
  					function.setFunctionName(functionName);
  			}
  		(<BLANK>)* 
  		terms=expr() 
  			{
  				function.setValue(terms);
  			} 
  		<RPAREN> 
  		(<BLANK>)*
  	}
  	catch (ParseException e) {
  		errorRecover(e, "f: function()", BLANK, SEMICOLON, RPAREN);
  	}
  	finally {
  		if(log.isTraceEnabled()) {
  			log.trace("Matched function: " + function);
  		}
  		return function; 
  	}
}

/**
 * Unary minus
 */
String minus() :
{ Token t; } { t=<MINUS>		{ return t.image; } }


/**
 * Name of function
 */
String function_begin() :  
{ Token t; } { t=<FUNCTION>		{ return t.image.substring(0,t.image.length()-1); } }

/**
 * Selector operator
 */
Selector.Operator equal() :      
{} {	<EQUAL> 	{ return Selector.Operator.EQUALS; } }

/**
 * Selector operator
 */
Selector.Operator includes() :   
{} {	<INCLUDES> 	{ return Selector.Operator.INCLUDES; } }

/**
 * Selector operator
 */
Selector.Operator dashmatch() :  
{} {	<DASHMATCH> { return Selector.Operator.DASHMATCH; } }

/**
 * Operator comma for terms
 */
Term.Operator comma() :  
{} { <COMMA> { return Term.Operator.COMMA; } }

/**
 * Operator slash for terms
 */
Term.Operator slash() :
{} { "/" { return Term.Operator.SLASH; } }


/**
 * Returns text represenatation of hex color
 */
String hexcolor() :
{
	String hex = null;
}
{
  hex = hash() (<BLANK>)* { return hex; }
}


/**
 * Identificator
 * @return Text name of identificator
 */
String ident() : 
{ Token t; } {	t = <IDENT>	{ return t.image; } }


/**
 * String value
 */
String string() :   
{ Token t; } { t=<STRING>	{ return t.image.substring(1,t.image.length()-1); } }

/**
 * URI value
 */
String uri() :      
{ Token t; } { t=<URI>		{ return t.image.substring(3,t.image.length()-1); } }

/**
 * String or URI value
 */
String string_or_uri():
{
	String value = null;
}
{
	value = string() { return value;} | value = uri() { return value; }
}

/**
 * Numerical value
 */
String number() :     
{ Token t; } { t=<NUMBER>	{ return t.image; } }

/**
 * Percentage value
 */
String percentage() : 
{ Token t; } { t=<PERCENTAGE>	{ return t.image; } } 

/**
 * Lenght in pixels
 */
String lengthpx() :   
{ Token t; } { t=<LENGTHPX>	{ return t.image; } }

/**
 * Lenght in centimeters
 */
String lengthcm() :   
{ Token t; } { t=<LENGTHCM>	{ return t.image; } }

/**
 * Lenght in milimeters
 */
String lengthmm() :   
{ Token t; } { t=<LENGTHMM>	{ return t.image; } }

/**
 * Length in point size
 */
String lengthpt() :   
{ Token t; } { t=<LENGTHPT>	{ return t.image; } }

/**
 * Lenght in pc
 */ 
String lengthpc() :   
{ Token t; } { t=<LENGTHPC>	{ return t.image; } }

/**
 * Length in ems
 */
String ems() :
{ Token t; } { t=<EMS>		{ return t.image; } }

/**
 * Lenght in exs
 */
String exs() :
{ Token t; } { t=<EXS>		{ return t.image; } }

/**
 * Length in deg	
 */
String angledeg() :   
{ Token t; } { t=<ANGLEDEG>	{ return t.image; } }

/**
 * Length in rad
 */
String anglerad() :
{ Token t; } { t=<ANGLERAD> { return t.image; } }

/**
 * Length in grad
 */
String anglegrad() :  
{ Token t; } { t=<ANGLEGRAD>	{ return t.image; } }

/**
 * Time in milliseconds
 */
String timems() : 
{ Token t; } { t=<TIMEMS>	{ return t.image; } }

/**
 * Time in seconds
 */
String times() :      
{ Token t; } { t=<TIMES>	{ return t.image; } }

/**
 * Frequency in Hz
 */	
String freqhz() :     
{ Token t; } { t=<FREQHZ>	{ return t.image; } }

/**
 * Frequency in kHz
 */
String freqkhz() :    
{ Token t; } { t=<FREQKHZ> 	{ return t.image; } }

/**
 * Hash-prefixed value
 */
String hash() :       
{ Token t; } { t=<HASH>		{ return t.image; } }


/**
 * Returns plus combinator
 */
Selector.Combinator plus() : 
{}	{ <PLUS>  { return Selector.Combinator.ADJACENT;} }

/**
 * Returns greater combinator
 */
Selector.Combinator greater():
{} { <GREATER>	{ return Selector.Combinator.CHILD;} }
